协程：又叫微线程。一种用户态轻量级线程。英文名Coroutine
    协程是一个单线程。
    协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。
    因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态。
    换种说法：进入上一次离开时所处逻辑流的位置。

协程的好处：
    无需线程上下文的开销。
    无需原子操作锁定及同步开销（因为协程是在一个线程里面进行的，切换有我们程序员自己控制。）
        　"原子操作(atomic operation)是不需要synchronized"，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序是不可以被打乱，或者切割掉只执行部分。视作整体是原子性的核心。
    方便切换控制流，简化编程模型
    高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。

协程的缺点：
    无法利用多核资源：协程的本质是个单线程，它不能同时将单个CPU的多个核用上，协程要和进程配合才能运行在多CPU上。当然我们日常所编写的绝大部分都没有这个必要，除非是CPU密集型的。
    进行阻塞操作会阻塞掉整个程序。

    CPU密集型任务：没有IO阻塞，但是会发送大量的切换。切换时有代价的，可能导致效率比串行还低。


协程的并发理论上可以无限大。

协程定义：
我们先给协程一个标准定义：即符合什么条件就能称之为协程：
    必须在只有一个单线程里实现并发
    修改共享数据不需加锁
    用户程序里自己保存多个控制流的上下文栈
    一个协程遇到IO操作自动切换到其它协程




高级模式：
    开多个进程：使用多核
    每个进程中开一个线程：GIL限制
    一个线程里面使用协程：高并发


greenlet是一个用C实现的协程模块，相比与python自带的yield，它可以使你在任意函数之间随意切换，而不需把这个函数先声明为generator


gevent：支持的协程
    Python通过yield提供了对协程的基本支持，但是不完全。而第三方的gevent为Python提供了比较完善的协程支持。
    gevent是第三方库，通过greenlet实现协程，其基本思想是：
    当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。
    由于切换是在IO操作时自动完成，所以gevent需要修改Python自带的一些标准库，这一过程在启动时通过monkey patch完成：


Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。