一：函数式+面向对象
    函数式编程：

二：面向对象：
    函数：
        def + 函数名(参数列表):

    面向对象：
        class 类名字：=>类
        def   方法名：=>方法，方法列表中多了一个参数，而且是第一个参数self
        ###   self

三：面向对中执行方法（即函数）：
    函数：
        函数名(self,arg):参数列表，第一个参数就是self
    面向对象：

     先创建一个对象，通过这个对象来调用对应的方法。



    面向对象就是：类和对象的应用。

    类的对象的关系：
        对象通过一个类型指针，指向它所属的类（因为当通过对象调用方法时，需要找到对象所属的类，进而找到对应的方法）


    s1 = "abc" (等同于al = str("abc"))
    sl.upper()


    self参数：表示调用函数的对象（值为该对象的地址信息）。self永远时调用方法的对象。


四：面向对象三大特性：
    封装：把公用的变量封装到self里面。

    继承：类继承类。子类继承父类。
        语法：



    多肽：

五：构造方法：
    特性：
    obj = 类名()【这里会自动执行默认的构造方法】
        ①：创建对象
        ②：执行类的构造方法

    #注意：__init__方法对封装没有任何关系，只是我们强行使用它来进行数据的封装。

    使用场景：如果多个函数中有一些相同的参数，就可以转换为面向对象。


六：面向对象三大特性之：继承
    语法：
       class 子类名 (父类名)：
            pass


七：在子类中调用父类方法：
    方式一：super(子类类名,self).父类中的方法(.....)
    方式二：父类类名.父类中的方法(self,...其他参数..)

八：继承的用处：要在第三方库中某个类增加先得功能，继承。



九：Python多继承:
    class Father1:
        pass
    class Father2:
        pass

    class Son(Father1,Father2):
        pass

    多继承有一个问题：孩子么有，两个父类都有，那么在通过子类去调用这个方法时，应该如何选择？
        规则如何：？

    ①：（无交叉）
        A
        |
        B      C
        \      /
            D

        查找顺序：先在左边找，如果B有就用B的，如果B没有就一级级向上找直到A，如果A也没有，才找C。

    ②：（有交叉）
            V
        /     \
        A      E
        |      |
        B      C
        \      /
            D

        查找顺序：先在左边找，如果B有就用B的，如果B没有就一级级向上找直到A，如果A也没有(注意此刻不会继续往上找V)，然后开始从右边找C-》E;最后才是找V


     总结：
        a:左侧优先
        b:一条道走到黑。
        c:左右，都是同一个根时，根最后执行。



    构造器的执行：
        A:单继承：
            a:子类默认无__init__时，则会直接继承父类__init__
            b:子类中含有__init__时，不会自动调用父类__init__，如需使用父类__init__中的变量，则需要在子类__init__中显式调用
        B:多继承:
            a:子类继承于多个父类，并且子类无__init__时，则按继承顺序，哪个父类在最前面且有自己的__init__，则继承它；若最前面的父类无__init__，则继承第二个父类的__init__，若还是无__init__，则依次往后寻找，直到继承的某个父类含__init__
            b:子类继承于多个父类，并且子类含__init__时，和单继承的（2）类似，不会自动调用所有父类__init__，如需使用某个父类__init__中的变量，则需要在子类__init__中显式调用，此处不再赘述


十：多态：Python中可以不考虑多态。python原生支持多态。
    Python是弱类型：
    Java是强类型：定义变量时必须指定变量类型。


十一：类的成员：

    class Foo:
        def __init__(self,name)：
           #字段（普通字段）
           self.name = name

        #方法（普通方法）
        def show(self):
            print(self.name)

    字段：保存到对象里面。使用字段，不用加括号。
    方法：保存到类里面；执行方法需要加括号

    类成员：
        #字段：
            普通字段：保存在对象中，只能通过对象来访问。
            静态字段：保存在类中，可以直接通过类名访问；静态字段也可以通过，对象访问。静态字段只保留一份，在类中

        #方法：
            普通方法：保存在类中，只能通过对象来访问。
            静态方法：保存在类中，可以直接通过类名访问。
                ①：需要使用@staticmethod，装饰器来
                ②：静态方法中self不用再传给方法了。
                @staticmethod
                def sta():#静态方法中self不用再传给方法了。
                    print("123")
            类方法：保存到类中，由类直接调用，cls参数===表示当前类

        什么时候用这些方法：？===========#########应用场景
            ①：希望在对象中保存一些值，而调用方法执行个哥功能时需要用到对象中的值：使用普通方法。
            ②：想用某个功能，不需要依赖其他对象中的值：静态方法。
            ③：类方法和静态方法没有多大差异，如果在执行方法时需要用到当前类时：类方法。【类方法的功能，完全可以通过静态方法构造出来】


        #属性：定义时像方法，但是执行时像字段。
            定义时需要使用：@property装饰器。
            执行时不用像方法一样添加括号。
            可以像字段一样给属性赋值：




#中国的所有省份，用面向对象？
class Province:
    #静态字段：属于类
    country = "中国"
    def __init__(self,name):
        #普通字段：属于对象
        self.name = name

henan = Province('河南')
hebei = Province('河北')

#静态字段：可以直接通过类名访问。
Province.country